# -*- coding: utf-8 -*-
"""midterm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O188J-owrXDAp8txIUxZiSTmT3V2Lapm
"""

import pandas as pd
data = pd.read_csv('gts-seoul.csv')

# 문제1
# 습도, 풍속, 현지기압, 기온, 이슬점 온도
tmp = data[data['일시'] == '2011-03-21 06:00']
tmp['습도'] + tmp['풍속'] + tmp['현지기압'] + tmp['기온'] + tmp['이슬점 온도']

# 문제2
data = data[['습도','풍속','현지기압','기온','이슬점 온도']]
data = data.dropna()
len(data) + data['습도'].mean() + data['풍속'].max() + data['기온'].min()

# 문제3-1
def corr(a,b):
  a = a - a.mean()
  b = b - b.mean()
  return (a * b).sum() / (((a * a).sum() * (b * b).sum()) ** 0.5)
  
a = corr(data['습도'],data['이슬점 온도'])
b = corr(data['풍속'],data['이슬점 온도'])
c = corr(data['현지기압'],data['이슬점 온도'])
d = corr(data['기온'],data['이슬점 온도'])
print(a,b,c,d)
print(a,b,c,d)

# 문제3-2
import matplotlib.pyplot as plt

plt.figure(dpi=200)
plt.subplot(2,2,1)
plt.scatter(data['습도'], data['이슬점 온도'], s=0.1)

plt.subplot(2,2,2)
plt.scatter(data['풍속'], data['이슬점 온도'], s=0.1)

plt.subplot(2,2,3)
plt.scatter(data['현지기압'], data['이슬점 온도'], s=0.1)

plt.subplot(2,2,4)
plt.scatter(data['기온'], data['이슬점 온도'], s=0.1)

# 문제3-3
data = data[(data['현지기압']<200) == False]
data

# 문제3-4
def corr(a,b):
  a = a - a.mean()
  b = b - b.mean()
  return (a * b).sum() / (((a * a).sum() * (b * b).sum()) ** 0.5)
  
a = corr(data['습도'],data['이슬점 온도'])
b = corr(data['풍속'],data['이슬점 온도'])
c = corr(data['현지기압'],data['이슬점 온도'])
d = corr(data['기온'],data['이슬점 온도'])
print(a,b,c,d)
print(a+b+b+d)

# 문제3-5
import matplotlib.pyplot as plt

plt.figure(dpi=200)
plt.subplot(2,2,1)
plt.scatter(data['습도'], data['이슬점 온도'], s=0.1)

plt.subplot(2,2,2)
plt.scatter(data['풍속'], data['이슬점 온도'], s=0.1)

plt.subplot(2,2,3)
plt.scatter(data['현지기압'], data['이슬점 온도'], s=0.1)

plt.subplot(2,2,4)
plt.scatter(data['기온'], data['이슬점 온도'], s=0.1)

# 문제4-1
from sklearn.linear_model import LinearRegression
model = LinearRegression()

X = data[['습도','풍속','현지기압','기온']]
Y = data['이슬점 온도']

model.fit(X,Y)
print(model.coef_) # w
print(model.intercept_) # b

# 문제4-2

predicted = model.predict(X)
((predicted - Y)**2).mean()

# 여기서부터 냥이갱얼쥐 문제
# 문제1

import pickle
data = pickle.load(open("mid_animal_data_pub.pkl","rb"))

import matplotlib.pyplot as plt

plt.figure(dpi=150)
for i in range(10):
  plt.subplot(5,2,i+1)
  plt.imshow(data['test1_images'][i])

plt.show

# 문제2

def cosine(a,b):
  return (a * b).sum() / (((a * a).sum() * (b * b).sum()) ** 0.5)
  
cosine(data['train_vectors'][0],data['test1_vectors'][1])

# 문제3

ids = []
for i in range(10):
  arr = []
  for j in range(data['train_vectors'].shape[0]):
    arr.append((cosine(data['test1_vectors'][i], data['train_vectors'][j]),j))
  arr.sort(reverse=True)
  ids.append([i for c,i in arr[:3]])

# 346, 442, 158

# 문제4

plt.figure(dpi=150)
i = 1
for arr in ids:
  for j in arr:
    plt.subplot(10,3,i)
    plt.imshow(data['train_images'][j])
    plt.axis("off")
    i+=1
  plt.show

# 문제5

import torch
import torch.nn as nn
import torch.nn.functional as F

x_train = torch.from_numpy(data["train_vectors"])
y_train = torch.from_numpy(data["train_labels"])

model = nn.Linear(256,3)

optim = torch.optim.Adam(model.parameters(), lr=0.01)

for epoch in range(10001):
    z = model(x_train)
    cost = F.cross_entropy(z, y_train)

    optim.zero_grad()
    cost.backward()
    optim.step()

    with torch.no_grad():
        if epoch % 1000 == 0:
            print(f"epoch: {epoch}, cost: {cost.item()}")

# 문제6

test2 = torch.from_numpy(data['test2_vectors'])

ans = torch.argmax(model(test2), dim=1)
"".join([str(x) for x in ans.tolist()])